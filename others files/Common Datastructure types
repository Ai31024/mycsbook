#These informations are taken from video called "10 Key Data Structure We Use Every Day" by ByteByteGo.

//These are common datastructures used in programming

1. List:
Lists are versatile and essential datastructures in software development.
They are great for storing and manipulating ordered data.

They are useful in various applications like task management, social media feeds, user preferences
and shopping carts.

In task management applications, a list can be used to store and organize task for each user.
Task can be added, removed or reordered easily and users can mark them as complete or incomplete.

Lists are also useful in social media applications like twitter, where they can store and display
a user's feed in real-time, ensuring the latest content is shown in the correct order.

2. Arrays:
Arrays are another fundamental data structure.
They provide a fixed-size ordered collection of elements.
They are particularly well-suited for situations where the size of the collection
is known or doesn't change frequently.
Arrays are commonly used in mathematical operations, storing large data sets,
or when there is a need for randm access to elements.

For example: In a weather application, an array could be used to store temperature readings
for a specifics location over a defined period.
This allows for easy calculations like averages and trends.

Arrays are also widely used in image processing where each pixel's color data can be represented
in a two-dimensional array. It enables efficient manipulation and transformation of the image.

3. Stacks:
Stacks follow the Last-In-First-Out (LIFO) principle. They are perfect for supporting undo/redo operations
in text editors or maintaining browsing history in web browsers.

In text editor, a stack can be used to storeeach change made to the text,
Making it simple to revert to a previous state when the user triggers and undo operation.

4. Queues:
Queues operate on a First-In-First-Out (FIFO) basis.
They are good for managing printer jobs, sending usr actions in games or handling messages in chat applications.
In chat applications, a queue can be used to store incoming messages in the order they are received.

5. Heaps:
Heaps, on the other hand are used for task scheduling and memory management.
They are especially helpful in implementing priority queues, where we need to access the highest or lowest priority item efficiently.

6. Trees:
Trees organize data hierarchically. They are useful for representing data with natural hierarchies or relationships.
They can be used in various applications like database indexing, AI decision making, and files systems.

In AI decision-making, trees like decision trees are used in machine learning for classification tasks.

Trees are also used in database indexing, where they can help speed up search, insert or delete operations.
For example, B trees and B+ trees are commonly used in relational database to efficiently manage and index large amount of data.

7. Hash Tables:
Hash Tables allows for efficient data lookup, insertion and deletion.
They use a hash function to map keys to their corresponding storage locations.
It enables constant time access to the stores values. Hash tables are widely used in various applications, such as search engines,
caching systems and programming language interpreters or compilers.

In search engines, hash tables can be used to store and quickly retrieve indexed data based on keywords.
This provides fast and relevant search results.

Caching systems may use hash tables to store and manage cached data. It allows for rapid access to frequently requested
resources and improves overall system performance.

Another example is the implementation of symbol tables in programming language interpreters or compilers.
Hash tables can be used to efficiently manage and look up variables, functions and other symbols defined in the source code.

8. Suffix trees:
Suffix trees are specialized for searching strings in documents.
This makes them perfect for text editors and search algorithms.
In a search engine, a suffix tree can be used to efficiently locate all occurrences of a search term
within a large corpus of text.

9. Graphs:
Graphs are all about tracking relationships or finding paths. This makes them invaluable in social networks,
recommendation engines and pathfinding algorithms.

In a social network, a graph can be used to represent the connections between users.
It enables features like friend suggestions or analyzing network trends.

10. R-Trees:
R-trees are good at finding nearest neighbors. They are crucial for mapping apps and geolocation services.
In a mapping application, R-trees can be used to store spatial data such as points of interest.
This enables efficient queries to find the nearest locations based on the user's current position.

IMPORTANT NOTES:
Cache Friendliness and how it relates to various data structures, including lists, arrays and others mentioned above.
CPU cache is a small, fast memory between the main memory (Random Access memory) and the CPU.
It stores recently accessed data and instructions, so the CPU can access them quickly without fetching them from
the slower main memory. Different data structures have varying levels of cache friendliness based on how their elementsare stored in memory.

Contiguous memory storage, like that in arrays, allows for better cache locality and fewer cache misses, resulting in improved performance.
When an array element is accessed, the cache can prefetch and store nearby elements, anticipating taht they might be accessed soon.

On the other hand, data structures with non-contiguous memory storage, like linked list, can experience more cache misses and reduced
performance. In a linked list, elements are stored in nodes scattered throughout the memory and each node contains a pointer to the next
node in the sequence. This makes it difficult for the CPU to predict and load the next node before it's needed.

Other data structures, such as trees, hash tables and graphs also have varying degrees of cache friendliness based on their implementation
and use case. This disparity in access times can lead to performance issues in modern computing,
particularly in situations where cache misses occur frequently. We should be mindful of this when working
with performance-critical applications and choose the appropriate data structure based on the specific requirements
and constraints of their projects.