C++ tutorial:

for reference : https://en.cppreference.com/w/
-----------------------
Variable Scope & Data Types

Variables, scopes: (see code1)

A Variable is a container to hold data 
primarily these are : 
    1. int : integer, i.e., 0, 1, 2... 9 or 23, 334, 55332
    2. float : Float, i.e., 0.1, 2.3, 22.7
    3. char : Character, i.e., a to z or A to Z
    4. double : Double float, i.e., 5.4432223 etc.
    5. bool : Boolean, i.e., True (1) or False (0)

eg: > int sum = 34 ; This means, the term called "sum" is an integer which holds value 34 in the memory.

Based on scope, variable can be classified into two types: 1. Local Variables 2. Global Variables

Scope of a variable is the region in code where the existence of variable is valid.
Local Variable : Local variables are declared inside the braces of any function and can be accessed only from there.
Global Variable : Global variables are declared outside any function and can be accessed from anywhere.
Global and Local variable can have same name.

calling a variable inside a function always prefers the local variable.
-----------------------
Data Types: (see code1)

Data Types define the type of data a variable can hold, for example an integer variable can hold integer data, a Character type variable can hold Character data etc.

Data Types in Cpp are categorised in three group:
1. Build-in. 
2. User-Defined.
3. Derived.

Rules to declare variables in c++:
    1. Variable names in c++ can range from 1 to 255 characters.
    2. All variable names must begin with a letter of the alphabet or an underscore.
    3. After the first initial letter, variable names can also contain letters and numbers.
    4. Variable names are case sensitive.
    5. No space or special characters are allowed.
    6. You cannot use a C++ reserved keywords as a variable name.
-----------------------
Basic i/o in c++: (see code2)

<< is called Insertion operator.
>> is called Extraction operator.

cout is "console out"
cin is "console in"

-----------------------
Header files & Operators: (see code3)

There are 2 type of header files.

    1. System header files: It comes with the compiler
    2. User defined header files : It is written by the programmer.

during this course I created an empty header file called "myheader.h"

Common operators in C++:

    1. Arithmetic Operators : +, -, /, *, %, etc.
    2. Assignment Operators : =
    3. Comparision Operators : <, >, <=, >=, ==, !=, etc.
    4. Logical Operators : &&, ||, !(bool), etc.
    5. Increment and decrement operators : i++, i--, ++i, --i, i+=n, i-=n, etc.

simple increment : i++, ++i, i--, --i
specified increment : i+=n, i-=n
----------------------

Reference variables & Typecasting: (see code4)

Reference variables means that one variable can be called using different names. To make a different name refer to a perticular variable, we should use (&) sign before it.
i.e.,
    int a = 10;
    int &b = a;
after doing this, when we call "b" using "cout<<b<<endl;" that will print out value of a.
Because "b" became a different name for calling "a". Here, "b" refers to "a".

TypeCasting means to convert one type of datatype into another type of datatype.
----------------------

Constants, Manipulators & Operator precedence: (see code5)

Constants are just read only variables. Once they are written then that cannot change. written as "const".

Manipulators are text modifiers that modifies the output texts. e.g., endl, setw(this is in iomanip header file), etc.

operator precedence describes the order of priority or associativity on which the operator is going to execute.
----------------------

if-else & control structures: (see code6)

control structure gives flow and logic to a program.

types of basic control structure:
    1. Sequence structure
    2. Selection structure
    3. Loop structure

Sequence structure : Entry -> Action 1 -> Action 2 -> Exit.

Selection structure : Entry -> condition 1 -> Action 1 or else Action 2 -> Exit.

Loop structure : Entry -> condition 1 -> Action 1 repeats till condition 1 is differed then Action 2 -> Exit.

if-else, elif and switch case statement is shown as in code6.cpp.

----------------------

for, while and do-while loops in C++: (see code7)

loops in C++:
    There are 3 types of loops in C++:
        1. For loop
        2. While loop
        3. Do-while loop

difference between for loop, while loop and do-while loop.

----------------------

Break and continue: (see code8)

"break" function breaks and exits the loop chain if the related condition becomes true. Some loop function syntax may atleast run or print the code related to break function once.
"continue" function skips the loop code if the related condition becomes true and continues to run rest of the loop chain.
----------------------

Pointers in C++: (see code9)

Pointer (indicated using star *) is a type of datatype that holds the address of other datatypes. Here, "reference in C++ (i.e., &)" is needed for better understanding. 

& means 'Address of' operator and Reference variable.
* means 'Dereference' operator and pointer variable.
** means pointer to pointer variable and double dereference operator. This pointer tells us the address of the another pointer. 

pointers are used to store the address of other datatype in the computer's memory. It reserves the address of that datatype until program exits.

To see the memory address in which the other datatype is stored, here is an example:
    int a = 1;
    int* b = &a;
    cout<<b<<endl;
This will return an address of the memory in which interger "a" is stored.

If we want to see address of a datatype but without using pointer variable, then we can do as following example:
    int a = 1;
    cout<<&a<<endl;
By doing this we cannot store the address of variable "a" but we can only see it.

In order to see the value at address stored by the pointer we should use dereference operator. like in the following example:
    int a = 1;
    int* b = &a;
    cout<<"value at address of pointer 'b' : "<<*b<<endl;
this will give output as:
    value at address of pointer 'b' : 1
it literally gives out the value at address stored in pointer.

We can also put a pointer variable on a pointer variable. We do that by putting double stars on the datatype and assign it to another pointer as a reference. That will be called pointer to pointer variable. This stores the memory address of another pointer. We can see in the following example:
    int a = 1;
    int* b = &a;
    int** c = &b;
By writing this we can store address of an address, that stores an address of a variable.
In order to know the value at address of an address, We use double dereference operator.

we can create multiple pointer to pointers by using multiple stars and to get value at address we should use multiple dereference operators.
----------------------

Arrays and Pointers in C++: (see code10)

Arrays:
    Array is a collection of items of similar type stored in contigous memory locations. 
    Sometimes a simple variable is not enough to hold all the data.
    For example, lets say we want to store the marks of 2500 students, having 2500 different marks. For simple variable this task is not feasible.
    To solve this problem, we can define an array with size of 2500 that can hold the marks of all students.

Continuing the above example, if we want to initiate an array variable, we should write it as:
    int marks[2500];

We can also create an undefined size of array on initialization but the amount of element assigned to it later will define the size of array. Example:
    int box[] = {12,22,13,43,22,24};
this array size started as undefined but after assigning elements define size to it.

lets create an array of size 4:
    int box[4] = {12, 32, 33, 21};
by calling array with its element will give us the value stored in that element. Example:
    cout<<box[0]<<endl;
    cout<<box[2]<<endl;
    cout<<box[3]<<endl;
this will return output such as:
    12
    33
    21

Application between pointers and arrays:

We cannot assign a normal variable to an array, But we can assign a pointer variable to an array.
While assigning a pointer to an array we do not put 'address of' operator with array.
Here is an example:
    int box[10] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
    int* p = box;
By doing this we have initiated a pointer and assigned it with an array 'box'.

pointer arithmetic:
    new address = current address + i * size of datatype

in code example:
    int box[4] = {1,4,6,8};
    int* p = box;
    cout<<"value of box no. 0 : "<<*p<<endl;
this will give result:
    value of box no. 0 : 1

to get all values we use loop function:
    int box[4] = {1,4,6,8};
    int* p = box;
    for(int i, i < 4, i++)
    {
    cout<<"value of box no. "<<i<<" is "<<*(p+i)<<endl;
    }
this will give result:
    value of box no. 0 : 1
    value of box no. 1 : 4
    value of box no. 2 : 6
    value of box no. 3 : 8

same program can be written by using while and do-while loop.

we have written above code using specified Increment, but we can also write it using simple increment.
such as:
    int box[4] = {2,5,7,9};
    int* p = box;
    cout<<"The value at box[0] is : "<<*p++<<endl;
    cout<<"The value at box[1] is : "<<*p++<<endl;
    cout<<"The value at box[2] is : "<<*p++<<endl;
    cout<<"The value at box[3] is : "<<*p++<<endl;
the output will be as expected.
Remember, we cannot go beyond the size of array using pointer or it will give nonsense output.
----------------------

Structure, Union and Enums: (see code11, code12 & code13)

Structure:

In an array, datatype of every elemnent inside it is same.
But if we want to have an array like variable but with different datatype element, We should use Structure by using keyword 'Struct'.

syntax using an example:

    struct table                                    // Global Variable (can also be a local variable)
    {
        int a;
        float b;
        char c;
    };

    int main()
    {
        struct table box;
        box.a = 1024;
        box.b = 22.7;
        box.c = 'A' ;

        cout<<"Value of 'a' for box on struct table is: "<<box.a<<endl;
        cout<<"Value of 'b' for box on struct table is: "<<box.b<<endl;
        cout<<"Value of 'c' for box on struct table is: "<<box.c<<endl;
    }

the output will be:

    Value of 'a' for box on struct table is: 1024
    Value of 'b' for box on struct table is: 22.7
    Value of 'c' for box on struct table is: A

If we want to simplify struct then we can use typedef before creating a 'struct' and name it whatever is convienient.

Union:

Union is very similar to Structure. Union can create multiple elements but, only allows to assign value to one of them.
Union saves a lot of memory space by sharing common memory among all elements.
It only allocates the maximum memory required among all the elements.
Unlike structure where every element's memory is added up and then allocated.

syntax using an example:

    union table                                    // Global Variable (can also be local variable)
    {
        int a;
        float b;
        char c;
    };

    int main()
    {
        union table box;
        box.a = 1024;
        cout<<"Value of 'a' for box on union table is: "<<box.a<<endl;
    }

the output will be:

    Value of 'a' for box on union table is: 1024

Enums: 

this enumerates elements position with any variable.

syntax using an example:

    enum name {a, b, c};               // created an enum named 'name' with elements a, b, c.

    name x = a;                        // assigned x with a.
    name y = b;                        // assigned y with b.
    name z = c;                        // assigned z with c.

    cout<<x<<endl;                     // console out x
    cout<<y<<endl;                     // console out y
    cout<<z<<endl;                     // console out z

output will be:
    0                                  // because x is assigned with a whose position is 0.
    1                                  // because y is assigned with b whose position is 1.
    2                                  // because z is assigned with c whose position is 2.

----------------------

Functions and function prototypes:

Functions or functional programming (aka top-down programming) lets us create a program using many smaller function that are design to do a specific task and then they are called accordingly in the final main function.

for example:
    int fx1 (a, b)
    {
        int c;
        // some code written for fx1
        return c;
    }

    int fx2 (x, y)
    {
        int z;
        // some code written for fx2
        return z;
    }

    int main()
    {
        int a1, a2;
        cout<<"some string"<<fx1(a1, a2);
        // this will call fx1
        // main's variable will be assigned into fx1 variable
        // the function block fx1 will work using main's variable.

        int b1, b2;
        cout<<"some string"<<fx2(b1, b2);
        // this will call fx2 and in same way the procedure will take place.

        return 0;
    }

Function prototypes:

In case of writing a function block after the main block we should use 'function prototypes'.
By doing so, we assure the compiler that the smaller function will be there after the main block.

syntax:

    'datatype' 'function name' ('arguments')

example:

    int fx1(int a, int b);

    int main()
    {
        int a1, a2;
        cout<<"some string"<<fx1(a1, a2);
        // this will call fx1
        // main's variable will be assigned into fx1 variable
        // the function block fx1 will work using main's variable.

        int b1, b2;
        cout<<"some string"<<fx2(b1, b2);
        // this will call fx2 and in same way the procedure will take place.

        return 0;
    }

    int fx1 (a, b)
    {
        int c;
        // some code written for fx1
        return c;
    }